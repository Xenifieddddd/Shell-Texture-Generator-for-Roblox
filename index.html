<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Shell - Roblox Texture Layer Tool</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet" />
<link rel="icon" href="SimpleShellLogo.ico" type="image/x-icon" />
<style>
  body {
    margin: 0; 
    background: #000;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    overflow-x: hidden;
    text-align: center;
    min-height: 100vh;
    padding-bottom: 20px;
  }
  .glass-container {
    max-width: 600px;
    margin: 2rem auto 0 auto;
    background: rgba(255 255 255 / 0.06);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
    backdrop-filter: blur(15px);
    position: relative;
    z-index: 10;
  }
  h1, p, label { color:white; text-shadow:0 0 10px rgba(255 255 255 / 0.6);} 
  input[type="file"], input[type="number"], button {
    margin: 0.5rem 0;
    padding: 0.3rem 0.8rem;
    font-size: 0.85rem;
    border-radius: 14px;
    border: none;
    outline: none;
    background: rgba(255 255 255 / 0.12);
    color: white;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.2);
    cursor: pointer;
  }
  input[type="file"]::-webkit-file-upload-button {
    background: rgba(255 255 255 / 0.25);
    color:white;
    padding:0.3rem 0.8rem;
    font-size:0.85rem;
    border-radius:12px;
    border:none;
    cursor:pointer;
  }
  input[type="number"] { width:80px; text-align:center; border-radius:10px; }
  input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{ -webkit-appearance:none; }
  button {
    background: linear-gradient(135deg, white 0%, #ddd 100%);
    color:#000; font-weight:700;
  }
  #downloadLink { display:none; margin-top:1rem; padding:0.6rem 1.2rem; border-radius:12px; background:white; color:black; font-weight:700; }
  .switch{ position:relative; display:inline-block; width:50px; height:26px; }
  .switch input{ display:none; }
  .slider{ position:absolute; cursor:pointer; background-color:black; top:0; left:0; right:0; bottom:0; border-radius:34px; transition:0.4s; }
  .slider::before{ position:absolute; content:""; height:18px; width:18px; left:4px; bottom:4px; background:white; border-radius:50%; transition:0.4s; }
  input:checked + .slider{ background-color:#0f9d58; box-shadow:0 0 8px #0f9d58; }
  input:checked + .slider::before{ transform:translateX(24px); }
  #layerPreviews { max-width:600px; margin:1.5rem auto 3rem auto; max-height:400px; overflow-y:auto; background:rgba(255 255 255 / 0.08); border-radius:20px; padding:10px; }
  #layerPreviews img { width:100%; border-radius:12px; margin-bottom:10px; box-shadow:0 0 12px rgba(255 255 255 / 0.3);} 
</style>
</head>
<body>
<div class="glass-container">
    <h1>Simple Shell</h1>
    <p>Pixel-accurate shell texture generator for Roblox</p>

    <label>Upload Base Color Image:
      <input type="file" id="baseColor" accept="image/png, image/jpeg" />
    </label><br/>

    <label>Upload Depth Map Image:
      <input type="file" id="depthMap" accept="image/png, image/jpeg" />
    </label><br/>

    <label>Number of Layers:
      <input type="number" id="layerCount" value="32" min="1" max="256" />
    </label><br/>

    <label>Make shells cumulative:
      <label class="switch"><input type="checkbox" id="cumulative"><span class="slider"></span></label>
    </label>

    <!-- NEW ACCUMULATION COUNT INPUT -->
    <div style="margin-top:0.5rem;">
      <label>Choose how many layers the shell texture will accumulate:</label><br>
      <input type="number" id="accumCount" value="2" min="2" max="256" />
    </div><br/>

    <label>Use Multi-step Downscale:
      <label class="switch"><input type="checkbox" id="multiStepDownscale"><span class="slider"></span></label>
    </label><br/>

    <button id="generateBtn">Generate Shell Layers</button>
    <div id="loadingSpinner"></div>
    <a id="downloadLink" href="#" download="shell_layers.zip"></a>
</div>

<div id="layerPreviews"></div>
<canvas id="workingCanvas" style="display:none;"></canvas>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
<script>
// FULLY PATCHED SHELL GENERATOR WITH ACCUMULATION LIMIT

// --- IMAGE LOADING ---
function loadImage(src){
  return new Promise(resolve=>{ const img=new Image(); img.onload=()=>resolve(img); img.src=src; });
}

// --- MULTISTEP DOWNSCALE ---
async function multiStepDownscale(img, maxDim=1024){
  let c=document.createElement('canvas'); let cx=c.getContext('2d');
  c.width=img.width; c.height=img.height; cx.drawImage(img,0,0);
  while(c.width>maxDim || c.height>maxDim){
    let nw=Math.max(maxDim, Math.floor(c.width/2));
    let nh=Math.max(maxDim, Math.floor(c.height/2));
    let t=document.createElement('canvas'); t.width=nw; t.height=nh;
    t.getContext('2d').drawImage(c,0,0,c.width,c.height,0,0,nw,nh);
    c=t;
  }
  return c;
}

// --- MAIN GENERATOR ---
async function generateShells(){
  const baseFile=document.getElementById('baseColor').files[0];
  const depthFile=document.getElementById('depthMap').files[0];
  const layerCountRaw=parseInt(document.getElementById('layerCount').value);
  const cumulative=document.getElementById('cumulative').checked;
  const useMultiStep=document.getElementById('multiStepDownscale').checked;

  let accumVal=parseInt(document.getElementById('accumCount').value);
  if(accumVal>layerCountRaw) accumVal=2;
  window._accumLimit=accumVal;

  const layerCount=Math.min(256,Math.max(1,layerCountRaw));
  const spinner=document.getElementById('loadingSpinner');
  const previews=document.getElementById('layerPreviews');
  const downloadLink=document.getElementById('downloadLink');
  const canvas=document.getElementById('workingCanvas');
  const ctx=canvas.getContext('2d');

  previews.innerHTML='';
  downloadLink.style.display='none';
  spinner.style.display='block';

  if(!baseFile || !depthFile){ alert("Please upload both images."); spinner.style.display='none'; return; }

  let baseImg=await loadImage(URL.createObjectURL(baseFile));
  let depthImg=await loadImage(URL.createObjectURL(depthFile));

  if(useMultiStep && (baseImg.width>1024 || baseImg.height>1024)) baseImg=await multiStepDownscale(baseImg,1024);
  if(useMultiStep && (depthImg.width>1024 || depthImg.height>1024)) depthImg=await multiStepDownscale(depthImg,1024);

  let scale=1;
  if(!useMultiStep && (baseImg.width>1024 || baseImg.height>1024)){
    scale=Math.min(1024/baseImg.width,1024/baseImg.height);
  }

  const width = useMultiStep ? baseImg.width : Math.floor(baseImg.width*scale);
  const height = useMultiStep ? baseImg.height : Math.floor(baseImg.height*scale);

  canvas.width=width; canvas.height=height;

  // Base
  ctx.drawImage(baseImg,0,0,width,height);
  const baseData=ctx.getImageData(0,0,width,height);

  // Depth
  ctx.drawImage(depthImg,0,0,width,height);
  const depthData=ctx.getImageData(0,0,width,height);

  const shells=[];
  const fadeRadius=6;

  for(let layer=0; layer<layerCount; layer++){
    const imgData=ctx.createImageData(width,height);

    const layerThreshold = layer/(layerCount-1);
    const limit=window._accumLimit;
    const start = Math.max(0, layerCount - limit);

    for(let i=0;i<baseData.data.length;i+=4){
      const depthVal=depthData.data[i]/255;

      let visible=false;
      if(cumulative){
        // FIX: smooth early-layer accumulation
        // Idea:
        // Instead of checking absolute depth thresholds tied to layer index,
        // we remap the current layer window (limited by accumLimit) into a
        // depth window. This avoids early empty layers.

        const limit = window._accumLimit;

        // Determine the first layer that should affect this shell
        // Example: limit=4 → layer0 uses 0→0, layer1 uses 0→1, layer2 uses 0→2...
        const startLayer = Math.max(0, layer - (limit - 1));
        const endLayer   = layer;

        // Convert both to depth thresholds
        const minDepth = startLayer / (layerCount - 1);
        const maxDepth = endLayer   / (layerCount - 1);

        // Pixel is visible if depth falls inside this continuous window
        if(depthVal >= minDepth && depthVal <= maxDepth){
          visible = true;
        }
      } else {
        const bandMin = layer/layerCount;
        const bandMax = (layer+1)/layerCount;
        if(depthVal>bandMin && depthVal<=bandMax) visible=true;
      }

      if(visible){
        imgData.data[i]=baseData.data[i];
        imgData.data[i+1]=baseData.data[i+1];
        imgData.data[i+2]=baseData.data[i+2];
        imgData.data[i+3]=baseData.data[i+3];
      } else imgData.data[i+3]=0;
    }

    // EDGE FADE
    const alphaCopy=new Uint8ClampedArray(imgData.data.length/4);
    for(let p=0;p<alphaCopy.length;p++) alphaCopy[p]=imgData.data[p*4+3];

    for(let y=0;y<height;y++){
      for(let x=0;x<width;x++){
        const idx=y*width+x;
        if(alphaCopy[idx]===0) continue;
        let minDist=fadeRadius+1;

        for(let oy=-fadeRadius;oy<=fadeRadius;oy++){
          for(let ox=-fadeRadius;ox<=fadeRadius;ox++){
            if(ox===0 && oy===0) continue;
            const nx=x+ox, ny=y+oy;
            if(nx<0||nx>=width||ny<0||ny>=height) continue;
            const nIdx=ny*width+nx;
            if(alphaCopy[nIdx]===0){
              const d=Math.sqrt(ox*ox+oy*oy);
              if(d<minDist) minDist=d;
            }
          }
        }

        if(minDist<=fadeRadius){
          const f=minDist/fadeRadius;
          imgData.data[idx*4+3]=Math.floor(alphaCopy[idx]*f);
        }
      }
    }

    shells.push(imgData);

    // Preview
    const prev=document.createElement('canvas');
    prev.width=width; prev.height=height;
    prev.getContext('2d').putImageData(imgData,0,0);
    const img=document.createElement('img');
    img.src=prev.toDataURL('image/png');
    previews.appendChild(img);
  }

  spinner.style.display='none';

  // ZIP EXPORT
  const zip=new JSZip();
  for(let i=0;i<shells.length;i++){
    const c=document.createElement('canvas'); c.width=width; c.height=height;
    c.getContext('2d').putImageData(shells[i],0,0);
    const blob=await new Promise(r=>c.toBlob(r,'image/png'));
    zip.file(`shell_layer_${String(i+1).padStart(3,'0')}.png`,blob);
  }
  const content=await zip.generateAsync({type:'blob'});
  const url=URL.createObjectURL(content);
  downloadLink.href=url; downloadLink.style.display='inline-block';
  downloadLink.textContent=`Download ${shells.length} shell layers (zip)`;
}

document.getElementById('generateBtn').addEventListener('click',generateShells);
</script>
</body>
</html>
