<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Shell - Roblox Texture Layer Tool</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet" />
<link rel="icon" href="SimpleShellLogo.ico" type="image/x-icon" />
<style>
  /* Base & Body */
  body {
    margin: 0; 
    background: #000;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    overflow-x: hidden;
    text-align: center;
    position: relative;
    min-height: 100vh;
    padding-bottom: 20px; /* no logo below now */
  }

  /* Glass UI container */
  .glass-container {
    max-width: 600px;
    margin: 2rem auto 0 auto;
    background: rgba(255 255 255 / 0.06);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
    backdrop-filter: blur(15px);
    position: relative;
    z-index: 10;
  }

  h1, p, label {
    margin: 0.5rem 0;
    color: white;
    text-shadow: 0 0 10px rgba(255 255 255 / 0.6);
  }

  /* Inputs styling (scaled down) */
  input[type="file"], input[type="number"], button {
    margin: 0.5rem 0;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 14px;
    border: none;
    outline: none;
    background: rgba(255 255 255 / 0.12);
    color: white;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.2);
    cursor: pointer;
  }

  /* File upload button style scaled down */
  input[type="file"]::-webkit-file-upload-button {
    background: rgba(255 255 255 / 0.25);
    color: white;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 12px;
    border: none;
    cursor: pointer;
    text-shadow: 0 0 6px rgba(255 255 255 / 0.6);
  }

  /* Number input style: rounded box */
  input[type="number"] {
    width: 80px;
    border-radius: 10px;
    text-align: center;
    -moz-appearance: textfield;
  }
  /* Remove number input arrows */
  input[type=number]::-webkit-inner-spin-button, 
  input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
  }

  /* Generate button */
  button {
    background: linear-gradient(135deg, white 0%, #ddd 100%);
    color: #000;
    font-weight: 700;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(135deg, #ddd 0%, white 100%);
  }

  /* Download link button */
  #downloadLink {
    display: none;
    margin-top: 1rem;
    text-decoration: none;
    padding: 0.6rem 1.2rem;
    border-radius: 12px;
    background: white;
    color: black;
    font-weight: 700;
    user-select: none;
    display: inline-block;
  }

  /* Cumulative toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 26px;
    vertical-align: middle;
  }
  .switch input { display:none; }
  .slider {
    position: absolute;
    cursor: pointer;
    background-color: black;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 34px;
    transition: background-color 0.4s ease;
  }
  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.4s ease;
  }
  input:checked + .slider {
    background-color: #0f9d58;
    box-shadow: 0 0 8px #0f9d58;
  }
  input:checked + .slider::before {
    transform: translateX(24px);
  }

  /* Parallax stars container */
  .parallax-stars {
    position: fixed;
    top: 0; left: 0;
    width: 200vw;
    height: 200vh;
    pointer-events: none;
    z-index: -10;
  }
  canvas.stars-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Loading spinner */
  #loadingSpinner {
    margin: 1rem auto;
    width: 48px;
    height: 48px;
    border: 5px solid rgba(255 255 255 / 0.15);
    border-top-color: #1cff87;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Container for individual layer previews */
  #layerPreviews {
    max-width: 600px;
    margin: 1.5rem auto 3rem auto;
    max-height: 400px;
    overflow-y: auto;
    background: rgba(255 255 255 / 0.08);
    border-radius: 20px;
    padding: 10px;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
  }

  /* Each layer preview image style */
  #layerPreviews img {
    width: 100%;
    border-radius: 12px;
    margin-bottom: 10px;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.3);
    user-select: none;
  }

  /* Normal map preview style */
  #previewNormal {
    height: 40px;
    vertical-align: middle;
    margin-left: 10px;
    display: none;
    border-radius: 6px;
    border: 1px solid rgba(255 255 255 / 0.3);
  }
#previewBase,
#previewDepth,
#previewNormal {
  max-width: 150px;
  max-height: 150px;
  display: block;
  margin: 0.5rem auto;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

</style>
</head>
<body>

  <div class="parallax-stars" id="parallaxStars"></div>

  <div class="glass-container">
    <h1>Simple Shell</h1>
    <p>Pixel-accurate shell texture generator for Roblox</p>

    <label>Upload Base Color Image:
      <input type="file" id="baseColor" accept="image/png, image/jpeg" />
      <img id="previewBase" />
    </label><br />

    <label>Upload Depth Map Image:
      <input type="file" id="depthMap" accept="image/png, image/jpeg" />
      <img id="previewDepth" />
    </label><br />

    <label>Upload Normal Map Image (optional):
      <input type="file" id="normalMap" accept="image/png, image/jpeg" />
      <img id="previewNormal" />
    </label><br />

    <label>Number of Layers:
      <input type="number" id="layerCount" value="32" min="1" max="256" />
    </label><br />

    <label>Make shells cumulative:
      <label class="switch">
        <input type="checkbox" id="cumulative" />
        <span class="slider"></span>
      </label>
    </label><br />

    <!-- Toggle for multi-step downscale -->
    <label>Use Multi-step Downscale:
      <label class="switch">
        <input type="checkbox" id="multiStepDownscale" />
        <span class="slider"></span>
      </label>
    </label><br />

    <button id="generateBtn">Generate Shell Layers</button>

    <div id="loadingSpinner"></div>

    <a id="downloadLink" href="#" download="shell_layers.zip"></a>
  </div>

  <div id="layerPreviews"></div>

  <canvas id="workingCanvas" style="display:none;"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    // --- STARFIELD WITH MULTI LAYER PARALLAX & FLICKERING ---
    const starLayers = 5;
    const starsPerLayer = 150;
    let starsData = [];
    const parallaxStarsDiv = document.getElementById('parallaxStars');

    for(let i = 0; i < starLayers; i++) {
      const canvas = document.createElement('canvas');
      canvas.classList.add('stars-canvas');
      canvas.width = window.innerWidth * 2;
      canvas.height = window.innerHeight * 2;
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.zIndex = (-starLayers + i).toString();
      parallaxStarsDiv.appendChild(canvas);

      const stars = [];
      for(let j = 0; j < starsPerLayer; j++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * (1.1 - 0.2) + 0.2,
          baseAlpha: 0.5 + Math.random() * 0.5,
          flickerPhase: Math.random() * Math.PI * 2,
          flickerSpeed: 0.001 + Math.random() * 0.002,
          canvas: canvas,
          context: canvas.getContext('2d')
        });
      }
      starsData.push(stars);
    }

    let mouseX = 0, mouseY = 0;
    let currentX = 0, currentY = 0;

    window.addEventListener('mousemove', e => {
      mouseX = e.clientX / window.innerWidth - 0.5;
      mouseY = e.clientY / window.innerHeight - 0.5;
    });

    function drawStars() {
      starsData.forEach((stars, layer) => {
        const ctx = stars[0].context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        stars.forEach(star => {
          star.flickerPhase += star.flickerSpeed;
          const alpha = star.baseAlpha + Math.sin(star.flickerPhase) * 0.3;
          const parallaxFactor = (layer + 1) / starLayers;
          const offsetX = currentX * 30 * parallaxFactor;
          const offsetY = currentY * 30 * parallaxFactor;

          ctx.beginPath();
          const glowAlpha = Math.min(Math.max(alpha, 0), 1);
          const glowColor = `rgba(255,255,255,${glowAlpha})`;
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 8;
          ctx.fillStyle = glowColor;
          ctx.arc(star.x + offsetX, star.y + offsetY, star.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      });
    }

    function updateParallax() {
      currentX += (mouseX - currentX) * 0.075;
      currentY += (mouseY - currentY) * 0.075;
      drawStars();
      requestAnimationFrame(updateParallax);
    }
    updateParallax();

    // --- IMAGE PREVIEWS FOR UPLOADED FILES ---
    function previewImage(inputId, imgId) {
      const input = document.getElementById(inputId);
      const preview = document.getElementById(imgId);
      input.addEventListener('change', () => {
        if(input.files && input.files[0]){
          const url = URL.createObjectURL(input.files[0]);
          preview.src = url;
          preview.style.display = 'inline-block';
        } else {
          preview.src = '';
          preview.style.display = 'none';
        }
      });
    }
    previewImage('baseColor', 'previewBase');
    previewImage('depthMap', 'previewDepth');
    previewImage('normalMap', 'previewNormal');

    // --- SHELL GENERATION ---

    const canvas = document.getElementById('workingCanvas');
    const ctx = canvas.getContext('2d');

    const loadingSpinner = document.getElementById('loadingSpinner');
    const downloadLink = document.getElementById('downloadLink');
    const layerPreviews = document.getElementById('layerPreviews');

    let width = 0;
    let height = 0;

    let currentZipUrl = null;

    // Multi-step downscale function: progressively scale down large images to maxDim preserving quality
    async function multiStepDownscale(img, maxDim = 1024) {
      let offscreen = document.createElement('canvas');
      let offctx = offscreen.getContext('2d');
      
      let srcWidth = img.width;
      let srcHeight = img.height;
      
      offscreen.width = srcWidth;
      offscreen.height = srcHeight;
      offctx.drawImage(img, 0, 0);
      
      while (offscreen.width > maxDim || offscreen.height > maxDim) {
        let nextWidth = offscreen.width > maxDim ? Math.max(maxDim, Math.floor(offscreen.width / 2)) : offscreen.width;
        let nextHeight = offscreen.height > maxDim ? Math.max(maxDim, Math.floor(offscreen.height / 2)) : offscreen.height;
        
        let temp = document.createElement('canvas');
        temp.width = nextWidth;
        temp.height = nextHeight;
        let tempCtx = temp.getContext('2d');
        
        tempCtx.drawImage(offscreen, 0, 0, offscreen.width, offscreen.height, 0, 0, nextWidth, nextHeight);
        
        offscreen = temp;
        offctx = tempCtx;
      }
      
      return offscreen;
    }

    async function generateShells() {
      downloadLink.style.display = 'none';
      layerPreviews.innerHTML = '';
      loadingSpinner.style.display = 'block';

      if(currentZipUrl){
        URL.revokeObjectURL(currentZipUrl);
        currentZipUrl = null;
      }

      const baseFile = document.getElementById('baseColor').files[0];
      const depthFile = document.getElementById('depthMap').files[0];
      const normalFile = document.getElementById('normalMap').files[0];
      const userLayerCountRaw = parseInt(document.getElementById('layerCount').value);
      const userLayerCount = Math.min(256, Math.max(1, userLayerCountRaw));
      const cumulative = document.getElementById('cumulative').checked;
      const useMultiStep = document.getElementById('multiStepDownscale').checked;

      if(!baseFile || !depthFile) {
        alert("Please upload both base color and depth map images.");
        loadingSpinner.style.display = 'none';
        return;
      }

      let baseImg = await loadImage(URL.createObjectURL(baseFile));
      let depthImg = await loadImage(URL.createObjectURL(depthFile));
      let normalImg = null;
      if(normalFile) {
        normalImg = await loadImage(URL.createObjectURL(normalFile));
      }

      if(useMultiStep && (baseImg.width > 1024 || baseImg.height > 1024)) {
        baseImg = await multiStepDownscale(baseImg, 1024);
      }
      if(useMultiStep && (depthImg.width > 1024 || depthImg.height > 1024)) {
        depthImg = await multiStepDownscale(depthImg, 1024);
      }

	function sharpenImage(image) {
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext('2d');
  canvas.width = image.width;
  canvas.height = image.height;

  ctx.filter = 'contrast(120%) saturate(120%)'; // Boost contrast & saturation first (optional)

  ctx.drawImage(image, 0, 0);

  // Simple convolution kernel for sharpening
  const kernel = [
    0, -1, 0,
    -1, 5, -1,
    0, -1, 0
  ];

  let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  let data = imageData.data;

  // Convolution function for sharpening
  function convolute(src, dst, width, height, kernel) {
    const side = Math.round(Math.sqrt(kernel.length));
    const halfSide = Math.floor(side / 2);

    for(let y = 0; y < height; y++) {
      for(let x = 0; x < width; x++) {
        let r = 0, g = 0, b = 0, a = 0;
        for(let ky = 0; ky < side; ky++) {
          for(let kx = 0; kx < side; kx++) {
            const posX = x + kx - halfSide;
            const posY = y + ky - halfSide;
            if(posX >= 0 && posX < width && posY >= 0 && posY < height) {
              const idx = (posY * width + posX) * 4;
              const weight = kernel[ky * side + kx];
              r += src[idx] * weight;
              g += src[idx + 1] * weight;
              b += src[idx + 2] * weight;
              a += src[idx + 3] * weight;
            }
          }
        }
        const dstIdx = (y * width + x) * 4;
        dst[dstIdx] = Math.min(Math.max(r, 0), 255);
        dst[dstIdx + 1] = Math.min(Math.max(g, 0), 255);
        dst[dstIdx + 2] = Math.min(Math.max(b, 0), 255);
        dst[dstIdx + 3] = Math.min(Math.max(a, 0), 255);
      }
    }
  }

  const outputData = new Uint8ClampedArray(data.length);
  convolute(data, outputData, canvas.width, canvas.height, kernel);

  // Copy back the sharpened pixels
  for(let i = 0; i < data.length; i++) {
    data[i] = outputData[i];
  }

  ctx.putImageData(imageData, 0, 0);

  // Return new Image from canvas
  const newImg = new Image();
  newImg.src = canvas.toDataURL();
  return newImg;
}

      if(normalImg && useMultiStep && (normalImg.width > 1024 || normalImg.height > 1024)) {
        normalImg = await multiStepDownscale(normalImg, 1024);
      }

      let scale = 1;
      if(!useMultiStep) {
        if(baseImg.width > 1024 || baseImg.height > 1024) {
          scale = Math.min(1024 / baseImg.width, 1024 / baseImg.height);
        }
      }

      width = useMultiStep ? baseImg.width : Math.floor(baseImg.width * scale);
      height = useMultiStep ? baseImg.height : Math.floor(baseImg.height * scale);

      canvas.width = width;
      canvas.height = height;

      // Draw base image and get data
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(baseImg, 0, 0, width, height);
      const baseData = ctx.getImageData(0, 0, width, height);

      // Draw depth image and get data
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(depthImg, 0, 0, width, height);
      const depthData = ctx.getImageData(0, 0, width, height);

      // If normal map exists, draw and get data
      let normalData = null;
      if(normalImg){
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(normalImg, 0, 0, width, height);
        normalData = ctx.getImageData(0, 0, width, height);
      }

      const allShells = [];

      // For smoother edge fade, smaller radius:
      const edgeFadeRadius = 2; // <-- Changed from 3 to 2 for less noticeable fade

      // Calculate internal shell count: 3 times user layers
      const internalLayerCount = (userLayerCount - 1) * 3;

      // Precompute baseDepth for comparison (depth from depth map grayscale)
      // depthData is RGBA, assume depth encoded in R channel or grayscale
      const baseDepthValues = new Float32Array(width * height);
      for(let i = 0; i < width * height; i++) {
        const idx = i * 4;
        // Use red channel normalized to 0-1 as depth
        baseDepthValues[i] = 1 - (depthData.data[idx] / 255);
      }

      // Generate internal shells
      for(let i = 0; i < internalLayerCount; i++) {
        const shellImageData = ctx.createImageData(width, height);

        // Threshold range for this shell
        const minDepth = i / internalLayerCount;
        const maxDepth = (i + 1) / internalLayerCount;

        // Loop over all pixels and slice based on depth range
        for(let p = 0; p < width * height; p++) {
          const idx = p * 4;
          const depthValue = baseDepthValues[p];

          if (depthValue > 0.001 && depthValue > minDepth && depthValue < maxDepth && depthValue < 0.999) {
            // Copy base color RGB to shell
            shellImageData.data[idx] = baseData.data[idx];
            shellImageData.data[idx + 1] = baseData.data[idx + 1];
            shellImageData.data[idx + 2] = baseData.data[idx + 2];
            shellImageData.data[idx + 3] = 255;
          } else {
            // Transparent pixel
            shellImageData.data[idx + 3] = 0;
          }
        }

        // Apply edge fade to reduce Roblox edge artifacts, except for first internal layer (base layer)
        if(i !== 0) {
          applyEdgeFade(shellImageData, width, height, edgeFadeRadius);
        }

        allShells.push(shellImageData);
      }

      const finalLayers = [];

// Push only the base color as the first visible layer, force full opacity
ctx.clearRect(0, 0, width, height);
ctx.drawImage(baseImg, 0, 0, width, height);
const baseLayerData = ctx.getImageData(0, 0, width, height);
for(let i = 0; i < baseLayerData.data.length; i += 4) {
  baseLayerData.data[i + 3] = 255; // force alpha = opaque
}
finalLayers.push(baseLayerData);

// Now push ONLY userLayerCount - 1 actual shell layers
for (let i = 1; i < userLayerCount; i++) {
  const combinedData = ctx.createImageData(width, height);

  if (cumulative) {
    for (let j = 1; j <= i * 3 + 2 && j < internalLayerCount; j++) {
      mergeImageData(combinedData, allShells[j]);
    }
  } else {
    const startIdx = i * 3;
    for (let j = startIdx; j <= i * 3 + 2 && j < internalLayerCount; j++) {
      mergeImageData(combinedData, allShells[j]);
    }
  }

  finalLayers.push(combinedData);
}

      // Clear existing previews and ZIP files before starting
layerPreviews.innerHTML = '';
const zip = new JSZip();

// Save all shell layers from top (shell 1) to base (shell N)
for (let i = 1; i < finalLayers.length; i++) {
  const imgData = finalLayers[i];
  const canvas = document.createElement('canvas');
  canvas.width = imgData.width;
  canvas.height = imgData.height;
  const ctx = canvas.getContext('2d');
  ctx.putImageData(imgData, 0, 0);
  const base64 = canvas.toDataURL().split(',')[1];
  
  const layerNum = finalLayers.length - i; // Reversed label
  zip.file(`shell_layer_${layerNum}.png`, base64, { base64: true });
}

// Save base layer (finalLayers[0]) last as highest number
const baseCanvas = document.createElement('canvas');
baseCanvas.width = finalLayers[0].width;
baseCanvas.height = finalLayers[0].height;
const baseCtx = baseCanvas.getContext('2d');
baseCtx.putImageData(finalLayers[0], 0, 0);
const baseBase64 = baseCanvas.toDataURL().split(',')[1];
zip.file(`shell_layer_${finalLayers.length}.png`, baseBase64, { base64: true });
}

// Generate ZIP and setup download link
zip.generateAsync({type:"blob"}).then(content => {
  if(currentZipUrl){
    URL.revokeObjectURL(currentZipUrl);
    currentZipUrl = null;
  }
  currentZipUrl = URL.createObjectURL(content);
  downloadLink.href = currentZipUrl;
  downloadLink.style.display = 'inline-block';
  downloadLink.textContent = `Download ${finalLayers.length} Layers ZIP`;
  loadingSpinner.style.display = 'none';
});
    }

    // Merge source ImageData into destination with alpha blending
    function mergeImageData(dest, src) {
      const d = dest.data;
      const s = src.data;
      for(let i = 0; i < d.length; i += 4) {
        const srcA = s[i + 3] / 255;
        const destA = d[i + 3] / 255;
        const outA = srcA + destA * (1 - srcA);
        if(outA > 0) {
          d[i] = (s[i] * srcA + d[i] * destA * (1 - srcA)) / outA;
          d[i + 1] = (s[i + 1] * srcA + d[i + 1] * destA * (1 - srcA)) / outA;
          d[i + 2] = (s[i + 2] * srcA + d[i + 2] * destA * (1 - srcA)) / outA;
          d[i + 3] = outA * 255;
        }
      }
    }

    function applyEdgeFade(imageData, width, height, threshold = 20, fuzziness = 10) {
  const data = imageData.data;
  for (let i = 0; i < width * height; i++) {
    const idx = i * 4;
    const r = data[idx];
    const g = data[idx + 1];
    const b = data[idx + 2];
    const brightness = (r + g + b) / 3;

    // Soft fade alpha using smoothstep
    if (brightness < threshold + fuzziness) {
      let fade = (brightness - threshold) / fuzziness;
      fade = Math.max(0, Math.min(1, fade)); // clamp
      data[idx + 3] *= fade;
    }
  }
}


    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    document.getElementById('generateBtn').addEventListener('click', generateShells);

  </script>

</body>
</html>
