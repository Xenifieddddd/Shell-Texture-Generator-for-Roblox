<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Simple Shell - Roblox Texture Layer Tool</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet" />
<link rel="icon" href="SimpleShellLogo.ico" type="image/x-icon" />
<style>
  /* Base & Body */
  body {
    margin: 0; 
    background: #000;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    overflow-x: hidden;
    text-align: center;
    position: relative;
    min-height: 100vh;
    padding-bottom: 20px; /* no logo below now */
  }

  /* Glass UI container */
  .glass-container {
    max-width: 600px;
    margin: 2rem auto 0 auto;
    background: rgba(255 255 255 / 0.06);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
    backdrop-filter: blur(15px);
    position: relative;
    z-index: 10;
  }

  h1, p, label {
    margin: 0.5rem 0;
    color: white;
    text-shadow: 0 0 10px rgba(255 255 255 / 0.6);
  }

  /* Inputs styling (scaled down) */
  input[type="file"], input[type="number"], button {
    margin: 0.5rem 0;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 14px;
    border: none;
    outline: none;
    background: rgba(255 255 255 / 0.12);
    color: white;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.2);
    cursor: pointer;
  }

  /* File upload button style scaled down */
  input[type="file"]::-webkit-file-upload-button {
    background: rgba(255 255 255 / 0.25);
    color: white;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 12px;
    border: none;
    cursor: pointer;
    text-shadow: 0 0 6px rgba(255 255 255 / 0.6);
  }

  /* Number input style: rounded box */
  input[type="number"] {
    width: 80px;
    border-radius: 10px;
    text-align: center;
    -moz-appearance: textfield;
  }
  /* Remove number input arrows */
  input[type=number]::-webkit-inner-spin-button, 
  input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
  }

  /* Generate button */
  button {
    background: linear-gradient(135deg, white 0%, #ddd 100%);
    color: #000;
    font-weight: 700;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(135deg, #ddd 0%, white 100%);
  }

  /* Download link button */
  #downloadLink {
    display: none;
    margin-top: 1rem;
    text-decoration: none;
    padding: 0.6rem 1.2rem;
    border-radius: 12px;
    background: white;
    color: black;
    font-weight: 700;
    user-select: none;
    display: inline-block;
  }

  /* Cumulative toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 26px;
    vertical-align: middle;
  }
  .switch input { display:none; }
  .slider {
    position: absolute;
    cursor: pointer;
    background-color: black;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 34px;
    transition: background-color 0.4s ease;
  }
  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.4s ease;
  }
  input:checked + .slider {
    background-color: #0f9d58;
    box-shadow: 0 0 8px #0f9d58;
  }
  input:checked + .slider::before {
    transform: translateX(24px);
  }

  /* Parallax stars container */
  .parallax-stars {
    position: fixed;
    top: 0; left: 0;
    width: 200vw;
    height: 200vh;
    pointer-events: none;
    z-index: -10;
  }
  canvas.stars-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Loading spinner */
  #loadingSpinner {
    margin: 1rem auto;
    width: 48px;
    height: 48px;
    border: 5px solid rgba(255 255 255 / 0.15);
    border-top-color: #1cff87;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Container for individual layer previews */
  #layerPreviews {
    max-width: 600px;
    margin: 1.5rem auto 3rem auto;
    max-height: 400px;
    overflow-y: auto;
    background: rgba(255 255 255 / 0.08);
    border-radius: 20px;
    padding: 10px;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
  }

  /* Each layer preview image style */
  #layerPreviews img {
    width: 100%;
    border-radius: 12px;
    margin-bottom: 10px;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.3);
    user-select: none;
  }

  /* Normal map preview style */
  #previewNormal {
    height: 40px;
    vertical-align: middle;
    margin-left: 10px;
    display: none;
    border-radius: 6px;
    border: 1px solid rgba(255 255 255 / 0.3);
  }
#previewBase,
#previewDepth,
#previewNormal {
  max-width: 150px;
  max-height: 150px;
  display: block;
  margin: 0.5rem auto;
  box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
}

</style>
</head>
<body>

  <div class="parallax-stars" id="parallaxStars"></div>

  <div class="glass-container">
    <h1>Simple Shell</h1>
    <p>Pixel-accurate shell texture generator for Roblox</p>

    <label>Upload Base Color Image:
      <input type="file" id="baseColor" accept="image/png, image/jpeg" />
      <img id="previewBase" />
    </label><br />

    <label>Upload Depth Map Image:
      <input type="file" id="depthMap" accept="image/png, image/jpeg" />
      <img id="previewDepth" />
    </label><br />

    <label>Upload Normal Map Image (optional):
      <input type="file" id="normalMap" accept="image/png, image/jpeg" />
      <img id="previewNormal" />
    </label><br />

    <label>Number of Layers:
      <input type="number" id="layerCount" value="32" min="1" max="256" />
    </label><br />

    <label>Make shells cumulative:
      <label class="switch">
        <input type="checkbox" id="cumulative" />
        <span class="slider"></span>
      </label>
    </label><br />

    <!-- Toggle for multi-step downscale -->
    <label>Use Multi-step Downscale:
      <label class="switch">
        <input type="checkbox" id="multiStepDownscale" />
        <span class="slider"></span>
      </label>
    </label><br />

    <button id="generateBtn">Generate Shell Layers</button>

    <div id="loadingSpinner"></div>

    <a id="downloadLink" href="#" download="shell_layers.zip"></a>
  </div>

  <div id="layerPreviews"></div>

  <canvas id="workingCanvas" style="display:none;"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    // --- STARFIELD WITH MULTI LAYER PARALLAX & FLICKERING ---
    const starLayers = 5;
    const starsPerLayer = 150;
    let starsData = [];
    const parallaxStarsDiv = document.getElementById('parallaxStars');

    for(let i = 0; i < starLayers; i++) {
      const canvas = document.createElement('canvas');
      canvas.classList.add('stars-canvas');
      canvas.width = window.innerWidth * 2;
      canvas.height = window.innerHeight * 2;
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.zIndex = (-starLayers + i).toString();
      parallaxStarsDiv.appendChild(canvas);

      const stars = [];
      for(let j = 0; j < starsPerLayer; j++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * (1.1 - 0.2) + 0.2,
          baseAlpha: 0.5 + Math.random() * 0.5,
          flickerPhase: Math.random() * Math.PI * 2,
          flickerSpeed: 0.001 + Math.random() * 0.002,
          canvas: canvas,
          context: canvas.getContext('2d')
        });
      }
      starsData.push(stars);
    }

    let mouseX = 0, mouseY = 0;
    let currentX = 0, currentY = 0;

    window.addEventListener('mousemove', e => {
      mouseX = e.clientX / window.innerWidth - 0.5;
      mouseY = e.clientY / window.innerHeight - 0.5;
    });

    function drawStars() {
      starsData.forEach((stars, layer) => {
        const ctx = stars[0].context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        stars.forEach(star => {
          star.flickerPhase += star.flickerSpeed;
          const alpha = star.baseAlpha + Math.sin(star.flickerPhase) * 0.3;
          const parallaxFactor = (layer + 1) / starLayers;
          const offsetX = currentX * 30 * parallaxFactor;
          const offsetY = currentY * 30 * parallaxFactor;

          ctx.beginPath();
          const glowAlpha = Math.min(Math.max(alpha, 0), 1);
          const glowColor = `rgba(255,255,255,${glowAlpha})`;
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 8;
          ctx.fillStyle = glowColor;
          ctx.arc(star.x + offsetX, star.y + offsetY, star.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      });
    }

    function updateParallax() {
      currentX += (mouseX - currentX) * 0.075;
      currentY += (mouseY - currentY) * 0.075;
      drawStars();
      requestAnimationFrame(updateParallax);
    }
    updateParallax();

    // --- IMAGE PREVIEWS FOR UPLOADED FILES ---
    function previewImage(inputId, imgId) {
      const input = document.getElementById(inputId);
      const preview = document.getElementById(imgId);
      input.addEventListener('change', () => {
        if(input.files && input.files[0]){
          const url = URL.createObjectURL(input.files[0]);
          preview.src = url;
          preview.style.display = 'inline-block';
        } else {
          preview.src = '';
          preview.style.display = 'none';
        }
      });
    }
    previewImage('baseColor', 'previewBase');
    previewImage('depthMap', 'previewDepth');
    previewImage('normalMap', 'previewNormal');

    // --- SHELL GENERATION ---

    const canvas = document.getElementById('workingCanvas');
    const ctx = canvas.getContext('2d');

    const loadingSpinner = document.getElementById('loadingSpinner');
    const downloadLink = document.getElementById('downloadLink');
    const layerPreviews = document.getElementById('layerPreviews');

    let width = 0;
    let height = 0;

    let currentZipUrl = null;

    // Multi-step downscale function: progressively scale down large images to maxDim preserving quality
    async function multiStepDownscale(img, maxDim = 1024) {
      let offscreen = document.createElement('canvas');
      let offctx = offscreen.getContext('2d');
      
      let srcWidth = img.width;
      let srcHeight = img.height;
      
      offscreen.width = srcWidth;
      offscreen.height = srcHeight;
      offctx.drawImage(img, 0, 0);
      
      while (offscreen.width > maxDim || offscreen.height > maxDim) {
        let nextWidth = offscreen.width > maxDim ? Math.max(maxDim, Math.floor(offscreen.width / 2)) : offscreen.width;
        let nextHeight = offscreen.height > maxDim ? Math.max(maxDim, Math.floor(offscreen.height / 2)) : offscreen.height;
        
        let temp = document.createElement('canvas');
        temp.width = nextWidth;
        temp.height = nextHeight;
        let tempCtx = temp.getContext('2d');
        
        tempCtx.drawImage(offscreen, 0, 0, offscreen.width, offscreen.height, 0, 0, nextWidth, nextHeight);
        
        offscreen = temp;
        offctx = tempCtx;
      }
      
      return offscreen;
    }

    async function generateShells() {
      downloadLink.style.display = 'none';
      layerPreviews.innerHTML = '';
      loadingSpinner.style.display = 'block';

      if(currentZipUrl){
        URL.revokeObjectURL(currentZipUrl);
        currentZipUrl = null;
      }

      const baseFile = document.getElementById('baseColor').files[0];
      const depthFile = document.getElementById('depthMap').files[0];
      const normalFile = document.getElementById('normalMap').files[0];
      const userLayerCountRaw = parseInt(document.getElementById('layerCount').value);
      const userLayerCount = Math.min(256, Math.max(1, userLayerCountRaw));
      const cumulative = document.getElementById('cumulative').checked;
      const useMultiStep = document.getElementById('multiStepDownscale').checked;

      if(!baseFile || !depthFile) {
        alert("Please upload both base color and depth map images.");
        loadingSpinner.style.display = 'none';
        return;
      }

      let baseImg = await loadImage(URL.createObjectURL(baseFile));
      let depthImg = await loadImage(URL.createObjectURL(depthFile));
      let normalImg = null;
      if(normalFile) {
        normalImg = await loadImage(URL.createObjectURL(normalFile));
      }

      if(useMultiStep && (baseImg.width > 1024 || baseImg.height > 1024)) {
        baseImg = await multiStepDownscale(baseImg, 1024);
      }
      if(useMultiStep && (depthImg.width > 1024 || depthImg.height > 1024)) {
        depthImg = await multiStepDownscale(depthImg, 1024);
      }
      if(normalImg && useMultiStep && (normalImg.width > 1024 || normalImg.height > 1024)) {
        normalImg = await multiStepDownscale(normalImg, 1024);
      }

      let scale = 1;
      if(!useMultiStep) {
        if(baseImg.width > 1024 || baseImg.height > 1024) {
          scale = Math.min(1024 / baseImg.width, 1024 / baseImg.height);
        }
      }

      width = useMultiStep ? baseImg.width : Math.floor(baseImg.width * scale);
      height = useMultiStep ? baseImg.height : Math.floor(baseImg.height * scale);

      canvas.width = width;
      canvas.height = height;

      // Draw base image and get data
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(baseImg, 0, 0, width, height);
      const baseData = ctx.getImageData(0, 0, width, height);

      // Draw depth image and get data
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(depthImg, 0, 0, width, height);
      const depthData = ctx.getImageData(0, 0, width, height);

      // If normal map exists, draw and get data
      let normalData = null;
      if(normalImg){
        ctx.clearRect(0, 0, width, height);
        ctx.drawImage(normalImg, 0, 0, width, height);
        normalData = ctx.getImageData(0, 0, width, height);
      }

      const allShells = [];

      // INTERNAL LAYER COUNT: 3x user layers, capped at 512 max
      const internalLayerCount = Math.min(512, userLayerCount * 3);

      // EDGE FADE SETTINGS
      const edgeFadeRadius = 3;

      // For each internal shell layer
      for(let i = 0; i < internalLayerCount; i++) {
        const shellImageData = ctx.createImageData(width, height);
        const depthThresholdLow = i / internalLayerCount;
        const depthThresholdHigh = (i + 1) / internalLayerCount;

        for(let px = 0; px < width * height; px++) {
          const idx = px * 4;

          // depth normalized from depth map alpha or brightness
          // Assuming depth map in grayscale, use red channel normalized
          let depthValue = 1 - depthData.data[idx] / 255;

          // Check if this pixel is in this shell layer range
          if(depthValue >= depthThresholdLow && depthValue < depthThresholdHigh) {
            // Copy base color
            shellImageData.data[idx] = baseData.data[idx];
            shellImageData.data[idx+1] = baseData.data[idx+1];
            shellImageData.data[idx+2] = baseData.data[idx+2];
            // Alpha mostly full (255), can be modulated with normal if available
            let alphaVal = 255;

            if(normalData){
              // Modulate alpha by normal intensity (example)
              alphaVal = Math.min(255, normalData.data[idx] + 50);
            }
            shellImageData.data[idx+3] = alphaVal;
          } else {
            // Transparent
            shellImageData.data[idx+3] = 0;
          }
        }

        // Apply edge fade: fade alpha near edges within edgeFadeRadius
        applyEdgeFade(shellImageData, width, height, edgeFadeRadius);

        allShells.push(shellImageData);
      }

      // Now generate the final user-visible layers by merging triples if cumulative = false
      const finalLayers = [];
      for(let i = 0; i < userLayerCount; i++) {
        // Start with blank image
        const combinedData = ctx.createImageData(width, height);

        if(cumulative) {
          // Merge all layers up to i * 3 + 2
          for(let j = 0; j <= i * 3 + 2 && j < internalLayerCount; j++) {
            mergeImageData(combinedData, allShells[j]);
          }
        } else {
          // Merge the triple group only (i*3, i*3+1, i*3+2)
          for(let j = i * 3; j <= i * 3 + 2 && j < internalLayerCount; j++) {
            mergeImageData(combinedData, allShells[j]);
          }
        }

        finalLayers.push(combinedData);
      }

      // Generate PNGs, show previews, and add to ZIP
      const zip = new JSZip();

      const baseFilename = baseFile.name.replace(/\.[^/.]+$/, "");

for(let i = 0; i < finalLayers.length; i++) {
  const reversedIndex = finalLayers.length - i - 1;

  ctx.putImageData(finalLayers[reversedIndex], 0, 0);
  const dataUrl = canvas.toDataURL('image/png');

  const img = new Image();
  img.src = dataUrl;
  layerPreviews.appendChild(img);

  const base64 = dataUrl.replace(/^data:image\/png;base64,/, "");
  zip.file(`shell_layer_${i+1}.png`, base64, {base64: true});
}

      // Generate zip blob
      const blob = await zip.generateAsync({type:"blob"});
      const url = URL.createObjectURL(blob);
      currentZipUrl = url;

      downloadLink.href = url;
      downloadLink.style.display = 'inline-block';
      downloadLink.textContent = `Download ${finalLayers.length} Shell Layers (ZIP)`;

      loadingSpinner.style.display = 'none';
    }

function applyEdgeFade(imageData, width, height, radius) {
  const data = imageData.data;
  const getAlpha = (x, y) => {
    if (x < 0 || x >= width || y < 0 || y >= height) return 0;
    return data[(y * width + x) * 4 + 3];
  };

  const shouldFade = new Uint8Array(width * height);

  // First pass: mark which pixels are near transparency
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      if (getAlpha(x, y) === 0) continue;

      // Check surrounding pixels
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx === 0 && dy === 0) continue;
          if (getAlpha(x + dx, y + dy) === 0) {
            shouldFade[idx] = 1;
          }
        }
      }
    }
  }

  // Second pass: apply fade only to marked pixels
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      const idx = y * width + x;
      if (!shouldFade[idx]) continue;

      const alphaIdx = idx * 4 + 3;
      let minDist = radius + 1;

      // Find distance to nearest transparent pixel within radius
      for (let oy = -radius; oy <= radius; oy++) {
        for (let ox = -radius; ox <= radius; ox++) {
          const nx = x + ox;
          const ny = y + oy;
          if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
          if (getAlpha(nx, ny) === 0) {
            const dist = Math.sqrt(ox * ox + oy * oy);
            if (dist < minDist) minDist = dist;
          }
        }
      }

      if (minDist <= radius) {
        const fade = minDist / radius;
        data[alphaIdx] = Math.floor(data[alphaIdx] * fade);
      }
    }
  }
}


    function mergeImageData(dest, src) {
      const d = dest.data;
      const s = src.data;
      for(let i = 0; i < d.length; i += 4) {
        if(s[i+3] === 0) continue;
        if(d[i+3] === 0){
          d[i] = s[i];
          d[i+1] = s[i+1];
          d[i+2] = s[i+2];
          d[i+3] = s[i+3];
        } else {
          // Alpha blend normal way
          const alphaS = s[i+3] / 255;
          const alphaD = d[i+3] / 255;
          const outA = alphaS + alphaD * (1 - alphaS);
          if(outA === 0) continue;
          d[i] = (s[i] * alphaS + d[i] * alphaD * (1 - alphaS)) / outA;
          d[i+1] = (s[i+1] * alphaS + d[i+1] * alphaD * (1 - alphaS)) / outA;
          d[i+2] = (s[i+2] * alphaS + d[i+2] * alphaD * (1 - alphaS)) / outA;
          d[i+3] = outA * 255;
        }
      }
    }

    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.crossOrigin = "anonymous";
        img.onload = () => resolve(img);
        img.onerror = reject;
        img.src = src;
      });
    }

    document.getElementById('generateBtn').addEventListener('click', () => {
      generateShells().catch(e => {
        alert("Error during generation: " + e.message);
        loadingSpinner.style.display = 'none';
      });
    });
  </script>

</body>
</html>
