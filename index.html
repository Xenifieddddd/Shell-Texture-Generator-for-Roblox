<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Shell Slicer - Roblox Texture Layer Tool</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap" rel="stylesheet" />
<style>
  /* Base & Body */
  body {
    margin: 0; 
    background: #000;
    color: #fff;
    font-family: 'Orbitron', sans-serif;
    overflow-x: hidden;
    text-align: center;
    position: relative;
    min-height: 100vh;
    padding-bottom: 20px; /* no logo below now */
  }

  /* Glass UI container */
  .glass-container {
    max-width: 600px;
    margin: 2rem auto 0 auto;
    background: rgba(255 255 255 / 0.06);
    border-radius: 20px;
    padding: 2rem;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
    backdrop-filter: blur(15px);
    position: relative;
    z-index: 10;
  }

  h1, p, label {
    margin: 0.5rem 0;
    color: white;
    text-shadow: 0 0 10px rgba(255 255 255 / 0.6);
  }

  /* Inputs styling (scaled down) */
  input[type="file"], input[type="number"], button {
    margin: 0.5rem 0;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 14px;
    border: none;
    outline: none;
    background: rgba(255 255 255 / 0.12);
    color: white;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.2);
    cursor: pointer;
  }

  /* File upload button style scaled down */
  input[type="file"]::-webkit-file-upload-button {
    background: rgba(255 255 255 / 0.25);
    color: white;
    padding: 0.3rem 0.8rem;    /* smaller padding */
    font-size: 0.85rem;        /* smaller font */
    border-radius: 12px;
    border: none;
    cursor: pointer;
    text-shadow: 0 0 6px rgba(255 255 255 / 0.6);
  }

  /* Number input style: rounded box */
  input[type="number"] {
    width: 80px;
    border-radius: 10px;
    text-align: center;
    -moz-appearance: textfield;
  }
  /* Remove number input arrows */
  input[type=number]::-webkit-inner-spin-button, 
  input[type=number]::-webkit-outer-spin-button { 
    -webkit-appearance: none; 
    margin: 0; 
  }

  /* Generate button */
  button {
    background: linear-gradient(135deg, white 0%, #ddd 100%);
    color: #000;
    font-weight: 700;
    transition: background 0.3s ease;
  }
  button:hover {
    background: linear-gradient(135deg, #ddd 0%, white 100%);
  }

  /* Download link button */
  #downloadLink {
    display: none;
    margin-top: 1rem;
    text-decoration: none;
    padding: 0.6rem 1.2rem;
    border-radius: 12px;
    background: white;
    color: black;
    font-weight: 700;
    user-select: none;
    display: inline-block;
  }

  /* Cumulative toggle switch */
  .switch {
    position: relative;
    display: inline-block;
    width: 50px;
    height: 26px;
    vertical-align: middle;
  }
  .switch input { display:none; }
  .slider {
    position: absolute;
    cursor: pointer;
    background-color: black;
    top: 0; left: 0; right: 0; bottom: 0;
    border-radius: 34px;
    transition: background-color 0.4s ease;
  }
  .slider::before {
    position: absolute;
    content: "";
    height: 18px;
    width: 18px;
    left: 4px;
    bottom: 4px;
    background-color: white;
    border-radius: 50%;
    transition: transform 0.4s ease;
  }
  input:checked + .slider {
    background-color: #0f9d58;
    box-shadow: 0 0 8px #0f9d58;
  }
  input:checked + .slider::before {
    transform: translateX(24px);
  }

  /* Parallax stars container */
  .parallax-stars {
    position: fixed;
    top: 0; left: 0;
    width: 200vw;
    height: 200vh;
    pointer-events: none;
    z-index: -10;
  }
  canvas.stars-canvas {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* Loading spinner */
  #loadingSpinner {
    margin: 1rem auto;
    width: 48px;
    height: 48px;
    border: 5px solid rgba(255 255 255 / 0.15);
    border-top-color: #1cff87;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    display: none;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }

  /* Container for individual layer previews */
  #layerPreviews {
    max-width: 600px;
    margin: 1.5rem auto 3rem auto;
    max-height: 400px;
    overflow-y: auto;
    background: rgba(255 255 255 / 0.08);
    border-radius: 20px;
    padding: 10px;
    box-shadow: 0 0 30px rgba(255 255 255 / 0.15);
    border: 1px solid rgba(255 255 255 / 0.1);
  }

  /* Each layer preview image style */
  #layerPreviews img {
    width: 100%;
    border-radius: 12px;
    margin-bottom: 10px;
    box-shadow: 0 0 12px rgba(255 255 255 / 0.3);
    user-select: none;
  }
</style>
</head>
<body>

  <div class="parallax-stars" id="parallaxStars"></div>

  <div class="glass-container">
    <h1>Simple Shell</h1>
    <p>Pixel-accurate shell texture generator for Roblox</p>

    <label>Upload Base Color Image:
      <input type="file" id="baseColor" accept="image/png, image/jpeg" />
      <img id="previewBase" style="height:40px; vertical-align: middle; margin-left:10px; display:none; border-radius:6px; border:1px solid rgba(255 255 255 / 0.3);" />
    </label><br />

    <label>Upload Depth Map Image:
      <input type="file" id="depthMap" accept="image/png, image/jpeg" />
      <img id="previewDepth" style="height:40px; vertical-align: middle; margin-left:10px; display:none; border-radius:6px; border:1px solid rgba(255 255 255 / 0.3);" />
    </label><br />

    <label>Number of Layers:
      <input type="number" id="layerCount" value="32" min="1" max="256" />
    </label><br />

    <label>Make shells cumulative:
      <label class="switch">
        <input type="checkbox" id="cumulative" />
        <span class="slider"></span>
      </label>
    </label><br />

    <button id="generateBtn">Generate Shell Layers</button>

    <div id="loadingSpinner"></div>

    <a id="downloadLink" href="#" download="shell_layers.zip"></a>
  </div>

  <div id="layerPreviews"></div>

  <canvas id="workingCanvas" style="display:none;"></canvas>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js"></script>
  <script>
    // --- STARFIELD WITH MULTI LAYER PARALLAX & FLICKERING ---
    const starLayers = 5;
    const starsPerLayer = 150;
    let starsData = [];
    const parallaxStarsDiv = document.getElementById('parallaxStars');

    for(let i = 0; i < starLayers; i++) {
      const canvas = document.createElement('canvas');
      canvas.classList.add('stars-canvas');
      canvas.width = window.innerWidth * 2;
      canvas.height = window.innerHeight * 2;
      canvas.style.position = 'absolute';
      canvas.style.top = '0';
      canvas.style.left = '0';
      canvas.style.zIndex = (-starLayers + i).toString();
      parallaxStarsDiv.appendChild(canvas);

      const stars = [];
      for(let j = 0; j < starsPerLayer; j++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          size: Math.random() * (1.1 - 0.2) + 0.2,
          baseAlpha: 0.5 + Math.random() * 0.5,
          flickerPhase: Math.random() * Math.PI * 2,
          flickerSpeed: 0.001 + Math.random() * 0.002,
          canvas: canvas,
          context: canvas.getContext('2d')
        });
      }
      starsData.push(stars);
    }

    let mouseX = 0, mouseY = 0;
    let currentX = 0, currentY = 0;

    window.addEventListener('mousemove', e => {
      mouseX = e.clientX / window.innerWidth - 0.5;
      mouseY = e.clientY / window.innerHeight - 0.5;
    });

    function drawStars() {
      starsData.forEach((stars, layer) => {
        const ctx = stars[0].context;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        stars.forEach(star => {
          star.flickerPhase += star.flickerSpeed;
          const alpha = star.baseAlpha + Math.sin(star.flickerPhase) * 0.3;
          const parallaxFactor = (layer + 1) / starLayers;
          const offsetX = currentX * 30 * parallaxFactor;
          const offsetY = currentY * 30 * parallaxFactor;

          ctx.beginPath();
          const glowAlpha = Math.min(Math.max(alpha, 0), 1);
          const glowColor = `rgba(255,255,255,${glowAlpha})`;
          ctx.shadowColor = glowColor;
          ctx.shadowBlur = 8;
          ctx.fillStyle = glowColor;
          ctx.arc(star.x + offsetX, star.y + offsetY, star.size, 0, Math.PI * 2);
          ctx.fill();
          ctx.shadowBlur = 0;
        });
      });
    }

    function updateParallax() {
      currentX += (mouseX - currentX) * 0.02;
      currentY += (mouseY - currentY) * 0.02;
      drawStars();
      requestAnimationFrame(updateParallax);
    }
    updateParallax();

    // --- IMAGE PREVIEWS FOR UPLOADED FILES ---
    function previewImage(inputId, imgId) {
      const input = document.getElementById(inputId);
      const preview = document.getElementById(imgId);
      input.addEventListener('change', () => {
        if(input.files && input.files[0]){
          const url = URL.createObjectURL(input.files[0]);
          preview.src = url;
          preview.style.display = 'inline-block';
        } else {
          preview.src = '';
          preview.style.display = 'none';
        }
      });
    }
    previewImage('baseColor', 'previewBase');
    previewImage('depthMap', 'previewDepth');

    // --- SHELL GENERATION ---

    const canvas = document.getElementById('workingCanvas');
    const ctx = canvas.getContext('2d');

    const loadingSpinner = document.getElementById('loadingSpinner');
    const downloadLink = document.getElementById('downloadLink');
    const layerPreviews = document.getElementById('layerPreviews');

    let width = 0;
    let height = 0;

    async function generateShells() {
      downloadLink.style.display = 'none';
      layerPreviews.innerHTML = '';
      loadingSpinner.style.display = 'block';

      const baseFile = document.getElementById('baseColor').files[0];
      const depthFile = document.getElementById('depthMap').files[0];
      const layerCount = Math.min(256, Math.max(1, parseInt(document.getElementById('layerCount').value)));
      const cumulative = document.getElementById('cumulative').checked;

      if(!baseFile || !depthFile) {
        alert("Please upload both base color and depth map images.");
        loadingSpinner.style.display = 'none';
        return;
      }

      const baseImg = await loadImage(URL.createObjectURL(baseFile));
      const depthImg = await loadImage(URL.createObjectURL(depthFile));

      let scale = 1;
      if(baseImg.width > 512 || baseImg.height > 512) {
        scale = Math.min(512/baseImg.width, 512/baseImg.height);
      }
      width = Math.floor(baseImg.width * scale);
      height = Math.floor(baseImg.height * scale);

      canvas.width = width;
      canvas.height = height;

      ctx.clearRect(0,0,width,height);
      ctx.drawImage(baseImg, 0, 0, width, height);
      const baseData = ctx.getImageData(0, 0, width, height);

      ctx.clearRect(0,0,width,height);
      ctx.drawImage(depthImg, 0, 0, width, height);
      const depthData = ctx.getImageData(0, 0, width, height);

      const allShells = [];

      for(let layer=0; layer < layerCount; layer++) {
        const imgData = ctx.createImageData(width, height);
        const t = layer / (layerCount - 1);

        for(let i=0; i < baseData.data.length; i += 4){
          const depthVal = depthData.data[i] / 255;
          if(cumulative){
            if(depthVal >= t){
              imgData.data[i] = baseData.data[i];
              imgData.data[i+1] = baseData.data[i+1];
              imgData.data[i+2] = baseData.data[i+2];
              imgData.data[i+3] = baseData.data[i+3];
            } else {
              imgData.data[i+3] = 0;
            }
          } else {
            const shellMin = layerCount === 1 ? 0 : (layer / layerCount);
            const shellMax = (layer + 1) / layerCount;
            if(depthVal > shellMin && depthVal <= shellMax){
              imgData.data[i] = baseData.data[i];
              imgData.data[i+1] = baseData.data[i+1];
              imgData.data[i+2] = baseData.data[i+2];
              imgData.data[i+3] = baseData.data[i+3];
            } else {
              imgData.data[i+3] = 0;
            }
          }
        }
        allShells.push(imgData);
      }

      // Render each layer as an image below
      for(let i = 0; i < allShells.length; i++) {
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = width;
        exportCanvas.height = height;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.putImageData(allShells[i], 0, 0);

        const img = document.createElement('img');
        img.src = exportCanvas.toDataURL('image/png');
        img.alt = `Shell Layer ${i+1}`;
        layerPreviews.appendChild(img);
      }

      loadingSpinner.style.display = 'none';

      // Prepare ZIP
      createZip(allShells);
    }

    function loadImage(src) {
      return new Promise(resolve => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.src = src;
      });
    }

    async function createZip(shells) {
      const zip = new JSZip();

      for(let i = 0; i < shells.length; i++) {
        const imgData = shells[i];
        const exportCanvas = document.createElement('canvas');
        exportCanvas.width = imgData.width;
        exportCanvas.height = imgData.height;
        const exportCtx = exportCanvas.getContext('2d');
        exportCtx.putImageData(imgData, 0, 0);

        // Await canvas to blob promise
        await new Promise(res => exportCanvas.toBlob(blob => {
          zip.file(`shell_layer_${i+1}.png`, blob);
          res();
        }, 'image/png'));
      }

      zip.generateAsync({type:"blob"}).then(content => {
        downloadLink.href = URL.createObjectURL(content);
        downloadLink.style.display = 'inline-block';
        downloadLink.textContent = `Download ZIP (${shells.length} layers)`;
      });
    }

    document.getElementById('generateBtn').addEventListener('click', generateShells);
  </script>

  <script defer src="https://analytics.vercel.com/script.js" data-token="YOUR_TOKEN_HERE"></script>

</body>
</html>
